# DAY02

## DOM

- 문서 객체 모델
- 문서의 구조화된 표현을 제공 프로그래밍 언어가 DOM 구조에 접근할 수 있는 방법을 제공
  - 문서 구조, 스타일, 내용 등을 변경할 수 있게 도움
  - HTML 콘텐츠를 추가, 제거, 변경하고, 동적(버튼)으로 페이지에 스타일을 추가함
- 문서가 구조화되어 있으며 각 요소는 객체로 취급
- 프로그래밍 언어적 특성을 활용한 조작 가능

- 문서를 논리 트리로 표현
- DOM 메서드를 사용하면 프로그래밍적으로 트리에 접근할 수 있고 이를 통해 문서의 구조, 스타일, 컨텐츠를 변경할 수 있음
- 웹 페이지는 일종의 문서
- 웹 브라우저를 통해 그 내용이 해석되어 웹 브라우저 화면에 나타나거나 HTML 코드 자체로 나타나기도 함
- DOM은 웹 페이지의 객체 지향 표현이며, JS와 같은 스크립트 언어를 이용해 DOM을 수정할 수 있음

#### DOM에 접근하기

- 특별히 할 일은 없음
- 주요 객체들을 활용하여 문서를 조작하거나 특정 요소를 얻을 수 있음

#### 주요 객체

- window

  - DOM 을 표현하는 창
  - 가장 최상위 객체 (생략이 가능)
  - 탭 기능이 있는 브라우저에서는 각각의 탭을 각각의 window 객체로 나타냄

  ```js
  새 탭 열기
  window.open()
  
  경고 창
  window.alert()
  
  인쇄 대화 창
  window.print()
  ```

- document

  - 브라우저가 불러온 웹 페이지
  - body 등과 같은 수많은 다른 요소들을 포함하고 있음
  - window 보다 하위 객체

```
title에 접근하기 
document.title = '싸피'
JS를 이용하여 객체로 접근
```

- 파싱 
  - 구문 분석, 해석
  - 브러우저가 문자열을 해석하여 DOM Tree로 만드는 과정
  - PARSE - STYLE - LAYOUT

#### DOM 조작

- 조작 순서
  1. 선택
  2. 조작 
     - 생성, 추가, 삭제 

1. 선택 관련 메서드

- .querySelector(경로)
  - 제공한 선택자와 일치하는 element 한 개 선택
  - 제공한 CSS selector를 만족하는 첫 번째 element 객체를 반환 (없다면 null 반환) 
  - 객체 하나 찾는 것 (여러 개 찾을 때 분리)
- .querySeletorAll()
  - 배열은 아니지만 배열처럼 사용할 수 있게 return 됨
  - 제공한 선택자와 일치하는 여러 element를 선택
  - 매칭 할 하나 이상의 셀렉터를 포함하는 유효한 CSS selector(문자열)를 인자로 받음
  - 제공한  CSS selector를 만족하는 NodeList를 반환

- NodeList
  - index로만 각 항목에 접근 가능
  - 배열의 forEach 메서드 및 다양한 배열 메서드 사용 가능
  - 실시간으로 반영하는데 querySeletorAll()는 정적인 것만 반영 실시간으로 하는 것 보다 유지하는 것이 좋기 때문에 
  - mdn NodeList 검색 용도에 맞게 사용

2. 조작 
   1. 생성
      - .createElement 
        - 요소를 생성하여 반환
      - .innerText
        - 줄 바꿈을 인식
   2. 추가
      - 누군가의 자식으로 넣어 줘야 함
      - .appendChild()
        - 한 Node를 특정 부모 Node의 자식 NodeList 중 마지막 자식으로 삽입
        - 한번에 오직 하나의 Node만 추가할 수 있음
        - 추가된 Node 객체를 반환
   3. 제거
      - .removeChild()
        - DOM 에서 자식 Node를 제거
   4. 속성
      - .getAttribute()
        - 값을 얻고자 하는 속성의 이름
      - .setAttribute(name, value)
        - 속성이 이미 존재하면 값을 갱신, 존재하지 않으면 지정된 이름과 값으로 새 속성을 추가

#### Event

- 프로그래밍하고 있는 시스템에서 일어나는 사건 혹은 발생
- 우리가 원한다면 그것들에 어떠한 방식으로 응답할 수 있도록 시스템이 말해 주는 것 (클릭, 마우스 오버, 입력 하는것도 Event, 자동 완성도 해당 등등 일어나는 모든 것)
- 네트워크 활동이나 사용자와의 상호작용 같은 사건의 발생을 알리기 위한 객체
- 받은 Event를 '처리' 할 수 있음
  - addEventListener() 이벤트 처리기(핸들러) 를 사용해 다양한 html 요소에 부착하게 됨
  - '대상에 특정 Event 가 발생하면, 할일을 등록하자'
  - EventTarget.addEventListener(type, listener(콜백함수))
  - 지정한 Event가 대상에 전달될 때마다 호출할 함수를 설정
  - Event를 지원하는 모든 객체를 대상으로 지정 가능
    - type 
      - 반응 할 Event 유형을 나타내는 대소문자 구분 문자열
      - input, click, submit ...
    - listener
      - 콜백 함수는 발생한 Event의 데이터를 가진 Event 기반 객체를 유일한 매개변수로 받음
      - type이 인자로 들어감 
      - 지정된 타입의 Event를 수신할 객체
- 취소
  - .preventDefault()
    - 현재 Event의 기본 동작을 중단
    - HTML 요소의 기본 동작을 작동하지 않게 막음
    - HTML 요소의 기본 동작 예시
      - a태그 : 클릭 시 특정 주소로 이동
      - form 태그 : form 데이터 전송

#### this 

- 어떠한 object를 가리키는 키워드 

- python 은 self 인스턴스 자기자신을 가리킴

- 일반적인 프로그래밍 언어에서의 this와 조금 다르게 동작

- 함수 호출 방식에 따라 this에 따라 달라짐

- 같은 함수라도 어떻게(how) 호출 되었는지에 따라 this라는 값이 달라짐 (동적으로 결정됨)

- 전역 문맥에서의 this 

  - 최상위 객체를 의미 (window)

- 함수 문맥에서의 this

  1. 단순 호출

     - 전역 객체를 가리킴
     - 전역은 브라우저에서는 window Node.js는 global을 의미함

  2. Method 객체의 메서드로서 

     - 메서드로 선언하고 호출한다면, 객체의 메서드이므로 해당 객체가 바인딩

  3. Nested

     - 함수 안에 함수에서 호출 할때

     - forEach의 콜백 함수에서의 this가 메서드의 객체를 가리키지 못하고 전역 객체 window를 가리킴 
     - 단순 호출 방식으로 사용되었기 때문
     - 이를 해결하기 위해 등장한 함수 표현식이 바로 '화살표 함수'
     - 화살표 함수에서 this는 자신을 감싼 정적 범위 
     - 자동으로 한 단계 상위의 scope의 context를 바인딩 

- 화살표 함수

  - 화살표 함수는 호출의 위치와 상관없이 상위 스코프를 카리킴
  - Lexical scope
    - 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정
    - Static scope 라고도 하며 대부분의 프로그래밍 언어에서 따르는 방식
  - 함수 내 함수 상황에서 화살표 함수를 쓰는 것을 권장
  - but .... addEventListener 에서의 콜백 함수는 특별하게 function 키워드의 경우 addEventListener를 호출한 대상을 뜻함 바로 위의 상위 스코프를 지칭하기 때문에 window 객체가 바인딩 됨 그러므로 addEventListener의 콜백 함수는 function 키워드를 사용하기 
  
- this 가 호출되는 순간에 결정되는 것 (런타임) 장점/ 단점

  - 함수(메서드)를 하나만 만들어서 여러 객체에서 재사용할 수 있다. (장점)

  - 이런 유연함이 실수로 이어질 수 있다는 단점이 있음
  - JS this 가 좋은지 나쁜지는 우리가 판단하는 게 중요한 것이 아님


